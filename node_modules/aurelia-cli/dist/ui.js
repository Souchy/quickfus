var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const os = require('os');
const fs = require('./file-system');
const { wordWrap } = require('enquirer/lib/utils');
const getTtySize = require('./get-tty-size');
const { Input, Select } = require('enquirer');
const prettyChoices = require('./workflow/pretty-choices');
const { Writable } = require('stream');
const _ = require('lodash');
exports.UI = class {
};
exports.ConsoleUI = class {
    constructor(cliOptions) {
        this.cliOptions = cliOptions;
    }
    log(text, indent) {
        if (indent !== undefined) {
            text = wordWrap(text, { indent, width: this.getWidth() });
        }
        return new Promise(resolve => {
            console.log(text);
            resolve();
        });
    }
    ensureAnswer(answer, question, suggestion) {
        return this._ensureAnswer(answer, question, suggestion);
    }
    // _debug is used to pass in answers for prompts.
    _ensureAnswer(answer, question, suggestion, _debug = []) {
        return __awaiter(this, void 0, void 0, function* () {
            if (answer)
                return answer;
            return yield this._question(question, suggestion, undefined, _debug);
        });
    }
    question(question, options, defaultValue) {
        return this._question(question, options, defaultValue);
    }
    // _debug is used to pass in answers for prompts.
    _question(question, options, defaultValue, _debug = []) {
        return __awaiter(this, void 0, void 0, function* () {
            let opts;
            let PromptType;
            if (!options || typeof options === 'string') {
                opts = {
                    message: question,
                    initial: options || '',
                    result: r => r.trim(),
                    validate: r => _.trim(r) ? true : 'Please provide an answer'
                };
                PromptType = Input;
            }
            else {
                options = options.filter(x => includeOption(this.cliOptions, x));
                if (options.length === 1) {
                    return options[0].value || options[0].displayName;
                }
                opts = {
                    type: 'select',
                    name: 'answer',
                    message: question,
                    initial: defaultValue || options[0].value || options[0].displayName,
                    choices: prettyChoices(options),
                    // https://github.com/enquirer/enquirer/issues/121#issuecomment-468413408
                    result(name) {
                        return this.map(name)[name];
                    }
                };
                PromptType = Select;
            }
            if (_debug && _debug.length) {
                // Silent output in debug mode
                opts.stdout = new Writable({ write(c, e, cb) { cb(); } });
            }
            return yield _run(new PromptType(opts), _debug);
        });
    }
    multiselect(question, options) {
        return this._multiselect(question, options);
    }
    // _debug is used to pass in answers for prompts.
    _multiselect(question, options, _debug = []) {
        return __awaiter(this, void 0, void 0, function* () {
            options = options.filter(x => includeOption(this.cliOptions, x));
            const opts = {
                multiple: true,
                message: question,
                choices: prettyChoices(options),
                validate: results => results.length === 0 ? 'Need at least one selection' : true,
                // https://github.com/enquirer/enquirer/issues/121#issuecomment-468413408
                result(names) {
                    return Object.values(this.map(names));
                }
            };
            if (_debug && _debug.length) {
                // Silent output in debug mode
                opts.stdout = new Writable({ write(c, e, cb) { cb(); } });
            }
            return yield _run(new Select(opts), _debug);
        });
    }
    getWidth() {
        return getTtySize().width;
    }
    getHeight() {
        return getTtySize().height;
    }
    displayLogo() {
        if (this.getWidth() < 50) {
            return this.log('Aurelia CLI' + os.EOL);
        }
        let logoLocation = require.resolve('./resources/logo.txt');
        return fs.readFile(logoLocation).then(logo => {
            this.log(logo.toString());
        });
    }
};
function includeOption(cliOptions, option) {
    if (option.disabled) {
        return false;
    }
    if (option.flag) {
        return cliOptions.hasFlag(option.flag);
    }
    return true;
}
function _run(prompt, _debug = []) {
    return __awaiter(this, void 0, void 0, function* () {
        if (_debug && _debug.length) {
            prompt.once('run', () => __awaiter(this, void 0, void 0, function* () {
                for (let d = 0, dd = _debug.length; d < dd; d++) {
                    let debugChoice = _debug[d];
                    if (typeof debugChoice === 'number') {
                        // choice index is 1-based.
                        while (debugChoice-- > 0) {
                            if (debugChoice) {
                                yield prompt.keypress(null, { name: 'down' });
                            }
                            else {
                                yield prompt.submit();
                            }
                        }
                    }
                    else if (typeof debugChoice === 'string') {
                        for (let i = 0, ii = debugChoice.length; i < ii; i++) {
                            yield prompt.keypress(debugChoice[i]);
                        }
                        yield prompt.submit();
                    }
                    else if (typeof debugChoice === 'function') {
                        yield debugChoice(prompt);
                    }
                }
            }));
        }
        return yield prompt.run();
    });
}
